import os
from asyncio import sleep
from datetime import datetime, timedelta
from random import choice
from traceback import format_exc
from pyrogram import filters, Client
from pyrogram.enums import ChatMemberStatus as CMS
from pyrogram.enums import ChatType as CT
from pyrogram.enums import MessageMediaType as MMT
from pyrogram.errors import UserNotParticipant
from pyrogram.types import CallbackQuery
from pyrogram.types import InlineKeyboardButton as IKB
from pyrogram.types import InlineKeyboardMarkup as IKM
from pyrogram.types import Message
from Hiroko import Hiroko
from Hiroko.Helper.database.giveawaydb import GIVEAWAY

LOGGER = -1001328686560

GA = GIVEAWAY()


user_entry = {}  # {c_id :  {participants_id : 0}}} dict be like
voted_user = {}  # {c_id : [voter_ids]}} dict be like
total_entries = {}  # {c_id : [user_id]} dict be like for participants
left_deduct = (
    {}
)  # {c_id:{u_id:p_id}} u_id = user who have voted, p_id = participant id. Will deduct vote from participants account if user leaves
rejoin_try = (
    {}
)  # store the id of the user who lefts the chat while giveaway under-process {c_id:[]}
is_start_vote = []  # store id of chat where voting is started





@Hiroko.on_message(filters.command("giveaway") & filters.private)
async def start_give_one(c : Hiroko, m : Message):
    uWu = True
    try:
        if m.chat.type != CT.PRIVATE:
            await m.reply_text("·¥ús·¥Ä…¢·¥á\n/startgiveaway\n·¥ç·¥á·¥Ä…¥·¥õ ·¥õ·¥è  ô·¥á ·¥ús·¥á·¥Ö …™…¥ ·¥ò Ä…™·¥†·¥Ä·¥õ·¥á")
            return
        g_id = await c.ask(
            text="s·¥á…¥·¥Ö ·¥ç·¥á …¥·¥ú·¥ç ô·¥á Ä ·¥è“ì …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è", chat_id=m.chat.id, filters=filters.text
        )
        give_id = g_id.text.markdown
        curr = GA.give_info(u_id=m.from_user.id)
        if curr:
            gc_id = curr["chat_id"]
            c_id = curr["where"]
            if curr["is_give"]:
                await m.reply_text("·¥è…¥·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è …™s ·¥Ä ü Ä·¥á·¥Ä·¥Ö è …™…¥ ·¥ò Ä·¥è…¢ Ä·¥áss")
                return
            while True:        
                con = await c.ask(
                    text=" è·¥è·¥ú …™…¥“ì·¥è …™s ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥ò Ä·¥ás·¥á…¥·¥õ …™…¥ ·¥ç è ·¥Ö·¥Ä·¥õ·¥Ä ô·¥Äs·¥á ·¥Ö·¥è  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ñ·¥è…¥·¥õ…™…¥·¥ú·¥á\n è·¥ás : ·¥õ·¥è s·¥õ·¥Ä Ä·¥õ ·¥õ ú·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è ·¥°…™·¥õ ú ·¥ò Ä·¥á·¥†…™·¥è·¥ús ·¥Ñ·¥è…¥“ì…™…¢·¥ú Ä·¥Ä·¥õ…™·¥è…¥s\n…¥·¥è: ·¥õ·¥è ·¥Ñ Ä·¥á·¥Ä·¥õ·¥á ·¥è…¥·¥á",
                    chat_id=m.chat.id,
                    filters=filters.text,
                )
                if con.text.lower() == "/cancel":
                    await m.reply_text("·¥Ñ·¥Ä…¥·¥Ñ·¥á ü ü·¥á·¥Ö")
                    return
                if con.text.lower() == "yes":
                    await c.send_message(m.chat.id, "·¥Ö·¥è…¥·¥á")
                    while True:
                        yes_no = await c.ask(
                            text="·¥è·¥ã.\n·¥Ö·¥è  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ä ü ü·¥è·¥° ·¥è ü·¥Ö ·¥ç·¥á·¥ç ô·¥á Ä ·¥è“ì ·¥õ ú·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü ·¥Ñ·¥Ä…¥ ·¥†·¥è·¥õ·¥á …™…¥ ·¥õ ú…™s …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è.\n** è·¥ás: ·¥õ·¥è ·¥Ä ü ü·¥è·¥°**\n**…¥·¥è: ·¥õ·¥è ·¥Ö·¥è…¥'·¥õ ·¥Ä ü ü·¥è·¥°**\n…¥·¥è·¥õ·¥á ·¥õ ú·¥Ä·¥õ ·¥è ü·¥Ö ·¥ç·¥á·¥Ä…¥ ·¥ús·¥á Ä ·¥° ú·¥è …™s ·¥ò Ä·¥ás·¥á…¥·¥õ …™…¥ ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ “ì·¥è Ä ·¥ç·¥è Ä·¥á ·¥õ ú·¥Ä…¥ 48  ú·¥è·¥ú Äs",
                            chat_id=m.from_user.id,
                            filters=filters.text,
                        )
                        if yes_no.text.lower() == "/cancel":
                            await m.reply_text("·¥Ñ·¥Ä…¥·¥Ñ·¥á ü ü·¥á·¥Ö")
                            return
                        if yes_no.text.lower() == "yes":
                            is_old = 0
                            break
                        elif yes_no.text.lower() == "no":
                            is_old = 1
                            break
                        else:
                            await c.send_message(m.chat.id, "·¥õ è·¥ò·¥á  è·¥ás ·¥è Ä …¥·¥è ·¥è…¥ ü è")
                    f_c_id = gc_id
                    s_c_id = c_id
                    is_old = is_old
                    GA.update_is_old(m.from_user.id, is_old)
                    GA.stop_entries(m.from_user.id, entries=1)  # To start entries
                    GA.stop_give(m.from_user.id, is_give=1)  # To start giveaway
                    link = await c.export_chat_invite_link(s_c_id)
                    uWu = False
                    await c.send_message(m.chat.id, "·¥Ö·¥è…¥·¥á")
                    break
                elif con.text.lower() == "no":
                    uWu = True
                    break
                else:
                    await c.send_message(m.chat.id, "·¥õ è·¥ò·¥á  è·¥ás ·¥è Ä …¥·¥è ·¥è…¥ ü è")
        if uWu:
            while True:
                channel_id = await c.ask(
                    text="·¥è·¥ã....s·¥á…¥·¥Ö ·¥ç·¥á …™·¥Ö ·¥è“ì ·¥õ ú·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü ·¥Ä…¥·¥Ö ·¥ç·¥Ä·¥ã·¥á s·¥ú Ä·¥á …™ ·¥Ä·¥ç ·¥Ä·¥Ö·¥ç…™…¥ ·¥õ ú·¥á…™ Ä. …™“ì  è·¥è·¥ú ·¥Ö·¥è…¥'·¥õ  ú·¥Ä·¥†·¥á …™·¥Ö “ì·¥è Ä·¥°·¥Ä Ä·¥Ö ·¥Ä ·¥ò·¥ès·¥õ “ì Ä·¥è·¥ç  è·¥è·¥ú Ä ·¥Ñ ú·¥Ä·¥õ.\n·¥õ è·¥ò·¥á /cancel ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü ·¥õ ú·¥á ·¥Ñ·¥ú Ä Ä·¥á…¥·¥õ ·¥ò Ä·¥è·¥Ñ·¥áss",
                    chat_id=m.chat.id,
                    filters=filters.text,
                )
                if channel_id.text:
                    if str(channel_id.text).lower() == "/cancel":
                        await c.send_message(m.from_user.id, "·¥Ñ·¥Ä…¥·¥Ñ·¥á ü ü·¥á·¥Ö")
                        return
                    try:
                        c_id = int(channel_id.text)
                        try:
                            bot_stat = (
                                await c.get_chat_member(c_id, Abishnoi.id)
                            ).status
                            if bot_stat in [CMS.ADMINISTRATOR, CMS.OWNER]:
                                break
                            else:
                                await c.send_message(
                                    m.chat.id,
                                    f" ü·¥è·¥è·¥ãs  ü…™·¥ã·¥á …™ ·¥Ö·¥è…¥'·¥õ  ú·¥Ä·¥†·¥á ·¥Ä·¥Ö·¥ç…™…¥ ·¥ò Ä…™·¥†…™ ü·¥á…¢·¥ás …™…¥ ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ {c_id}\n·¥ç·¥Ä·¥ã·¥á ·¥ç·¥á ·¥Ä·¥Ö·¥ç…™…¥ ·¥Ä…¥·¥Ö ·¥õ ú·¥á…¥ s·¥á…¥·¥Ö ·¥ç·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü …™·¥Ö ·¥Ä…¢·¥Ä…™…¥",
                                )
                        except UserNotParticipant:
                            await c.send_message(
                                m.chat.id,
                                f" ü·¥è·¥è·¥ãs  ü…™·¥ã·¥á …™ ·¥Ä·¥ç …¥·¥è·¥õ ·¥ò·¥Ä Ä·¥õ ·¥è“ì ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ {c_id}\n",
                            )

                    except ValueError:
                        await c.send_message(
                            m.chat.id, "·¥Ñ ú·¥Ä…¥…¥·¥á ü …™·¥Ö s ú·¥è·¥ú ü·¥Ö  ô·¥á …™…¥·¥õ·¥á…¢·¥á Ä ·¥õ è·¥ò·¥á"
                        )

                else:
                    if channel_id.forward_from_chat:
                        try:
                            bot_stat = (
                                await c.get_chat_member(c_id, Abishnoi.id)
                            ).status
                            if bot_stat in [CMS.ADMINISTRATOR, CMS.OWNER]:
                                break
                            else:
                                await c.send_message(
                                    m.chat.id,
                                    f" ü·¥è·¥è·¥ãs  ü…™·¥ã·¥á …™ ·¥Ö·¥è…¥'·¥õ  ú·¥Ä·¥†·¥á ·¥Ä·¥Ö·¥ç…™…¥ ·¥ò Ä…™·¥†…™ ü·¥á…¢·¥ás …™…¥ ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ {c_id}\n·¥ç·¥Ä·¥ã·¥á ·¥ç·¥á ·¥Ä·¥Ö·¥ç…™…¥ ·¥Ä…¥·¥Ö ·¥õ ú·¥á…¥ s·¥á…¥·¥Ö ·¥ç·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü …™·¥Ö ·¥Ä…¢·¥Ä…™…¥",
                                )
                        except UserNotParticipant:
                            await c.send_message(
                                m.chat.id,
                                f" ü·¥è·¥è·¥ãs  ü…™·¥ã·¥á …™ ·¥Ä·¥ç …¥·¥è·¥õ ·¥ò·¥Ä Ä·¥õ ·¥è“ì ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ {c_id}\n",
                            )
                    else:
                        await c.send_message(
                            m.chat.id,
                            f"“ì·¥è Ä·¥°·¥Ä Ä·¥Ö ·¥ç·¥á ·¥Ñ·¥è…¥·¥õ·¥á…¥·¥õ “ì Ä·¥è·¥ç ·¥Ñ ú·¥Ä·¥õ ·¥° ú·¥á Ä·¥á  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è s·¥õ·¥Ä Ä·¥õ …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è",
                        )
            f_c_id = c_id
            await c.send_message(m.chat.id, "·¥Ñ ú·¥Ä…¥…¥·¥á ü …™·¥Ö  Ä·¥á·¥Ñ·¥á…™·¥†·¥á·¥Ö")
            while True:
                chat_id = await c.ask(
                    text="s·¥á…¥·¥Ö·¥á ·¥ç·¥á …™·¥Ö ·¥è“ì ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ ·¥Ä…¥·¥Ö ·¥ç·¥Ä·¥ã·¥á s·¥ú Ä·¥á …™ ·¥Ä·¥ç ·¥Ä·¥Ö·¥ç…™…¥ ·¥õ ú·¥á…™ Ä. …™“ì  è·¥è·¥ú ·¥Ö·¥è…¥'·¥õ  ú·¥Ä·¥†·¥á …™·¥Ö …¢·¥è …™…¥ ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ ·¥Ä…¥·¥Ö ·¥õ è·¥ò·¥á /id.\n·¥õ è·¥ò·¥á /cancel ·¥õ·¥è ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü ·¥õ ú·¥á ·¥Ñ·¥ú Ä Ä·¥á…¥·¥õ ·¥ò Ä·¥è·¥Ñ·¥áss",
                    chat_id=m.chat.id,
                    filters=filters.text,
                )
                if chat_id.text:
                    if str(chat_id.text).lower() == "/cancel":
                        await c.send_message(m.from_user.id, "·¥Ñ·¥Ä…¥·¥Ñ·¥á ü ü·¥á·¥Ö")
                        return
                    try:
                        cc_id = int(chat_id.text)
                        try:
                            cc_id = (await c.get_chat(cc_id)).id
                            s_c_id = cc_id
                            break
                        except Exception:
                            try:
                                cc_id = await c.resolve_peer(cc_id)
                                cc_id = (await c.get_chat(cc_id.channel_id)).id
                                s_c_id = cc_id
                                break
                            except Exception as e:
                                await c.send_message(
                                    m.chat.id, f" ü·¥è·¥è·¥ãs  ü…™·¥ã·¥á ·¥Ñ ú·¥Ä·¥õ ·¥Ö·¥è·¥ás…¥'·¥õ ·¥áx…™s·¥õ: {e}"
                                )
                    except ValueError:
                        await c.send_message(
                            m.chat.id, "·¥Ñ ú·¥Ä·¥õ …™·¥Ö s ú·¥è·¥ú ü·¥Ö  ô·¥á …™…¥·¥õ·¥á…¢·¥á Ä ·¥õ è·¥ò·¥á"
                        )
                    try:
                        bot_stat = (await c.get_chat_member(s_c_id, Abishnoi.id)).status
                        if bot_stat in [CMS.ADMINISTRATOR, CMS.OWNER]:
                            break
                        else:
                            await c.send_message(
                                m.chat.id,
                                f" ü·¥è·¥è·¥ãs  ü…™·¥ã·¥á …™ ·¥Ö·¥è…¥'·¥õ  ú·¥Ä·¥†·¥á ·¥Ä·¥Ö·¥ç…™…¥ ·¥ò Ä…™·¥†…™ ü·¥á…¢·¥ás …™…¥ ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ {s_c_id}\n·¥ç·¥Ä·¥ã·¥á ·¥ç·¥á ·¥Ä·¥Ö·¥ç…™…¥ ·¥Ä…¥·¥Ö ·¥õ ú·¥á…¥ s·¥á…¥·¥Ö ·¥ç·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü …™·¥Ö ·¥Ä…¢·¥Ä…™…¥",
                            )
                    except UserNotParticipant:
                        await c.send_message(
                            m.chat.id,
                            f" ü·¥è·¥è·¥ãs  ü…™·¥ã·¥á …™ ·¥Ä·¥ç …¥·¥è·¥õ ·¥ò·¥Ä Ä·¥õ ·¥è“ì ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ {s_c_id}\n",
                        )

            await c.send_message(m.chat.id, "·¥Ñ ú·¥Ä·¥õ …™·¥Ö  Ä·¥á·¥Ñ·¥á…™·¥†·¥á·¥Ö")

            link = await c.export_chat_invite_link(cc_id)

            yes_no = await c.ask(
                text="·¥Ö·¥è  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ä ü ü·¥è·¥° ·¥è ü·¥Ö ·¥ç·¥á·¥ç ô·¥á Ä ·¥è“ì ·¥õ ú·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü ·¥Ñ·¥Ä…¥ ·¥†·¥è·¥õ·¥á …™…¥ ·¥õ ú…™s …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è.\n** è·¥ás: ·¥õ·¥è ·¥Ä ü ü·¥è·¥°**\n**…¥·¥è: ·¥õ·¥è ·¥Ö·¥è…¥'·¥õ ·¥Ä ü ü·¥è·¥°**\n…¥·¥è·¥õ·¥° ·¥õ ú·¥Ä·¥õ ·¥è ü·¥Ö ·¥ç·¥á·¥Ä…¥ user ·¥° ú·¥è …™s ·¥ò Ä·¥ás·¥á…¥·¥õ …™…¥ ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ “ì·¥è Ä ·¥ç·¥è Ä·¥á ·¥õ ú·¥Ä…¥ 48  ú·¥è·¥ú Äs",
                chat_id=m.from_user.id,
                filters=filters.text,
            )
            if yes_no.text.lower() == "yes":
                is_old = 0
            elif yes_no.text.lower() == "no":
                is_old = 1
            curr = GA.save_give(f_c_id, s_c_id, m.from_user.id, is_old, force_c=True)
    except Exception as e:
        LOGGER.error(e)
        LOGGER.error(format_exc())
        return

    reply = m.reply_to_message
    giveaway_text = f"""
**#…¢…™·¥†·¥á·¥Ä·¥°·¥Ä è {give_id} „Äã**
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
__·¥õ·¥è ·¥°…™…¥ ·¥õ ú…™s …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è__
__·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä·¥õ·¥á …™…¥ ·¥õ ú·¥á ·¥Ñ·¥è…¥·¥õ·¥ás·¥õ__,
__·¥Ñ·¥è·¥ç·¥ç·¥á…¥·¥õ /enter ·¥õ·¥è  ô·¥á…¢…™…¥__

 ô·¥è·¥õ s ú·¥è·¥ú ü·¥Ö  ô·¥á s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö!
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
**s·¥õ·¥Ä·¥õ·¥ús : ·¥á…¥·¥õ Ä…™·¥ás ·¥è·¥ò·¥á…¥**
"""

    kb = IKM(
        [
            [IKB("·¥ä·¥è…™…¥ ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ", url=link)],
            [IKB("s·¥õ·¥Ä Ä·¥õ ·¥õ ú·¥á  ô·¥è·¥õ", url=f"https://{Hiroko.username}.t.me/")],
        ]
    )
    try:
        if reply and (
            reply.media in [MMT.VIDEO, MMT.PHOTO]
            or (reply.document.mime_type.split("/")[0] == "image")
        ):
            if reply.photo:
                pin = await c.send_photo(
                    f_c_id, reply.photo.file_id, giveaway_text, reply_markup=kb
                )
            elif reply.video:
                pin = await c.send_video(
                    f_c_id, reply.video.file_id, giveaway_text, reply_markup=kb
                )
            elif reply.document:
                download = await reply.download()
                pin = await c.send_photo(
                    f_c_id, download, giveaway_text, reply_markup=kb
                )
                os.remove(download)
        else:
            pin = await c.send_message(
                f_c_id, giveaway_text, reply_markup=kb, disable_web_page_preview=True
            )
    except Exception as e:
        LOGGER.error(e)
        LOGGER.error(format_exc())
        await m.reply_text(f"“ì·¥Ä…™ ü·¥á·¥Ö ·¥õ·¥è s·¥á…¥·¥Ö ·¥ç·¥áss·¥Ä…¢·¥á ·¥õ·¥è ·¥Ñ ú·¥Ä…¥…¥·¥á ü ·¥Ö·¥ú·¥á ·¥õ·¥è\n{e}")
        return
    c_in = await c.get_chat(f_c_id)
    name = c_in.title
    await m.reply_text(
        f"‚ú® …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è ·¥ò·¥ès·¥õ  ú·¥Äs  ô·¥á·¥á…¥ s·¥á…¥·¥õ ·¥õ·¥è [{name}]({c_in.invite_link})",
        disable_web_page_preview=True,
        reply_markup=IKM([[IKB("…¢·¥è ·¥õ·¥è ·¥ò·¥ès·¥õ", url=pin.link)]]),
    )


async def message_editor(c: Hiroko, m: Message, c_id):
    txt = f"""
**#…¢…™·¥†·¥á·¥Ä·¥°·¥Ä è „Äã**
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
__·¥õ·¥è ·¥°…™…¥ ·¥õ ú…™s …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è__
__·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä·¥õ·¥á …™…¥ ·¥õ ú·¥á ·¥Ñ·¥è…¥·¥õ·¥ás·¥õ__,
__·¥Ñ·¥è·¥ç·¥ç·¥á…¥·¥õ /enter ·¥õ·¥è  ô·¥á…¢…™…¥__

…¥·¥è·¥õ·¥á:  ô·¥è·¥õ s ú·¥è·¥ú ü·¥Ö  ô·¥á s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö !
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
**s·¥õ·¥Ä·¥õ·¥ús : ·¥á…¥·¥õ Ä…™·¥ás ·¥Ñ ü·¥ès·¥á·¥Ö**
**·¥õ·¥è·¥õ·¥Ä ü ·¥á…¥·¥õ Ä…™·¥ás : {len(total_entries[c_id])}**
"""
    try:
        m_id = int(m.text.split(None)[1].split("/")[-1])
    except ValueError:
        await m.reply_text("·¥õ ú·¥á  ü…™…¥·¥ã ·¥Ö·¥è·¥ás…¥'·¥õ ·¥Ñ·¥è…¥·¥õ·¥Ä…™…¥ ·¥Ä…¥ è ·¥ç·¥áss·¥Ä…¢·¥á …™·¥Ö")
        return False
    try:
        mess = await c.get_messages(c_id, m_id)
    except Exception as e:
        await m.reply_text(
            f"“ì·¥Ä…™ ü·¥á·¥Ö ·¥õ·¥è …¢·¥á·¥õ ·¥ç·¥áss·¥Ä…¢·¥á “ì·¥è Ä·¥ç ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ …™·¥Ö {c_id}. ·¥Ö·¥ú·¥á ·¥õ·¥è “ì·¥è ü ü·¥è·¥°…™…¥…¢ ·¥á Ä Ä·¥è Ä\n{e}"
        )
        return False
    try:
        if mess.caption:
            await mess.edit_caption(txt)
        else:
            await mess.edit_text(txt)
        return True
    except Exception as e:
        await m.reply_text(f"“ì·¥Ä…™ ü·¥á·¥Ö ·¥õ·¥è ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á ·¥õ ú·¥á ·¥ç·¥áss·¥Ä…¢·¥á ·¥Ö·¥ú·¥á ·¥õ·¥è “ì·¥è ü ü·¥è·¥°…™…¥…¢ ·¥á Ä Ä·¥è Ä\n{e}")
        await m.reply_text(
            f" ú·¥á Ä·¥á …™s ·¥õ ú·¥á ·¥õ·¥áx·¥õ  è·¥è·¥ú ·¥Ñ·¥Ä…¥ ·¥á·¥Ö…™·¥õ ·¥õ ú·¥á ·¥ç·¥áss·¥Ä…¢·¥á  ô è  è·¥è·¥ú Ä s·¥á ü“ì\n`{txt}`\ns·¥è Ä Ä è “ì·¥è Ä …™…¥·¥Ñ·¥è…¥·¥†·¥á…¥…™·¥á…¥·¥Ñ·¥á"
        )
        return False


@Hiroko.on_message(filters.command("stopentry")
async def stop_give_entry(c: Hiroko, m: Message):
    u_id = m.from_user.id
    curr = GA.give_info(u_id=u_id)
    if not curr:
        await m.reply_text(" è·¥è·¥ú  ú·¥Ä·¥†·¥á …¥·¥è·¥õ s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥Ä…¥ è …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è  è·¥á·¥Ä·¥õ.")
        return
    if not curr["entries"]:
        await m.reply_text(" è·¥è·¥ú  ú·¥Ä·¥†·¥á …¥·¥è·¥õ s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥Ä…¥ è …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è  è·¥á·¥Ä·¥õ.")
        return
    user = curr["user_id"]
    if u_id != user:
        await m.reply_text(" è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥õ ú·¥á ·¥è…¥·¥á ·¥° ú·¥è  ú·¥Ä·¥†·¥á s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥õ ú·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è")
        return
    c_id = curr["chat_id"]
    if len(m.text.split(None)) != 2:
        await m.reply_text("**·¥ús·¥Ä…¢·¥á**\n`/stopentry <·¥ò·¥ès·¥õ  ü…™…¥·¥ã>`")
        return
    GA.stop_entries(u_id)
    z = await message_editor(c, m, c_id)
    if not z:
        return
    await m.reply_text("s·¥õ·¥è·¥ò·¥ò·¥á·¥Ö ·¥õ ú·¥á “ì·¥ú Ä·¥õ ú·¥á Ä ·¥á…¥·¥õ Ä…™·¥ás")
    return


def clean_values(c_id):
    try:
        rejoin_try[c_id].clear()
    except KeyError:
        pass
    try:
        user_entry[c_id].clear()
    except KeyError:
        pass
    try:
        left_deduct[c_id].clear()
    except KeyError:
        pass
    try:
        total_entries[c_id].clear()
    except KeyError:
        pass
    try:
        is_start_vote.remove(c_id)
    except ValueError:
        pass
    try:
        voted_user[c_id].clear()
    except KeyError:
        pass
    return


@Hiroko.on_message(filters.command("stopgiveaway", pm_only=True)
async def stop_give_away(c: Hiroko, m: Message):
    u_id = m.from_user.id
    curr = GA.give_info(u_id=u_id)
    if not curr:
        await m.reply_text(" è·¥è·¥ú  ú·¥Ä·¥†·¥á …¥·¥è·¥õ s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥Ä…¥ è …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è  è·¥á·¥õ")
        return
    if not curr["is_give"]:
        await m.reply_text(" è·¥è·¥ú  ú·¥Ä·¥†·¥á …¥·¥è·¥õ s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥Ä…¥ è …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è  è·¥á·¥õ")
        return
    user = curr["user_id"]
    c_id = curr["chat_id"]

    GA.stop_entries(u_id)
    GA.start_vote(u_id, 0)
    try:
        if not len(total_entries[c_id]):
            await m.reply_text("…¥·¥è ·¥á…¥·¥õ…™ Ä·¥ás “ì·¥è·¥ú…¥·¥Ö")
            GA.stop_give(u_id)
            clean_values(c_id)
            await m.reply_text("s·¥õ·¥è·¥ò·¥ò·¥á·¥Ö ·¥õ ú·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è")
            return
    except KeyError:
        await m.reply_text("…¥·¥è ·¥á…¥·¥õ…™ Ä·¥ás “ì·¥è·¥ú…¥·¥Ö")
        GA.stop_give(u_id)
        clean_values(c_id)
        await m.reply_text("s·¥õ·¥è·¥ò·¥ò·¥á·¥Ö ·¥õ ú·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è")
        return
    if u_id != user:
        await m.reply_text("You ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥õ ú·¥á ·¥è…¥·¥á ·¥° ú·¥è  ú·¥Ä·¥†·¥á s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥õ ú·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è")
        return
    try:
        if not len(user_entry[c_id]):
            await m.reply_text("…¥·¥è ·¥á…¥·¥õ Ä…™·¥ás “ì·¥è·¥ú…¥·¥Ö")
            GA.stop_give(u_id)
            clean_values(c_id)
            await m.reply_text("s·¥õ·¥è·¥ò·¥ò·¥á·¥Ö ·¥õ ú·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è")
            return
    except KeyError:
        GA.stop_give(u_id)
        clean_values(c_id)
        await m.reply_text("s·¥õ·¥è·¥ò·¥ò·¥á·¥Ö ·¥õ ú·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è")
        return
    GA.stop_give(u_id)
    try:
        if not len(voted_user[c_id]):
            clean_values(c_id)
            await m.reply_text("…¥·¥è ·¥†·¥è·¥õ·¥á Äs “ì·¥è·¥ú…¥·¥Ö")
            GA.stop_give(u_id)
            await m.reply_text("s·¥õ·¥è·¥ò·¥ò·¥á·¥Ö ·¥õ ú·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è")
            return
    except KeyError:
        GA.stop_give(u_id)
        clean_values(c_id)
        await m.reply_text("s·¥õ·¥è·¥ò·¥ò·¥á·¥Ö ·¥õ ú·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è")
        return
    # highest = max(user_entry[c_id], key=lambda k:user_entry[c_id][k])
    # high = user_entry[c_id][highest]
    max_value = max(user_entry[c_id].values())
    max_user = []
    for k, v in user_entry[c_id].items():
        if v == max_value:
            max_user.append(k)
    if len(max_user) == 1:
        high = max_value
        user_high = (await c.get_users(max_user[0])).mention
        txt = f"""
**…¢…™·¥†·¥á·¥Ä·¥°·¥Ä è ·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á** ‚úÖ
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚â° ·¥õ·¥è·¥õ·¥Ä ü ·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä…¥·¥õs: {len(total_entries[c_id])}
‚â° ·¥õ·¥è·¥õ·¥Ä ü …¥·¥ú·¥ç ô·¥á Ä of ·¥†·¥è·¥õ·¥ás: {len(voted_user[c_id])}

‚â° ·¥°…™…¥…¥·¥á Ä üèÜ : {user_high}
‚â° ·¥†·¥è·¥õ·¥á …¢·¥è·¥õ üó≥ : `{high}` ·¥†·¥è·¥õ·¥ás
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
>>>·¥õ ú·¥Ä…¥·¥ãs “ì·¥è Ä ·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä·¥õ…™…¥…¢
"""
    else:
        to_key = [
            "·¥ä·¥Ä…™  ú…™…¥·¥Ö",
            "·¥ä·¥Ä…™ ·¥ä·¥Ä·¥°·¥Ä·¥Ä…¥",
            "·¥ä·¥Ä…™  ô ú·¥Ä Ä·¥Ä·¥õ",
            "·¥ä·¥Ä…™ s ú Ä·¥á·¥á  Ä·¥Ä·¥ç",
            "·¥ä·¥Ä…™ s ú Ä·¥á·¥á s ú è·¥Ä·¥ç",
            "·¥ä·¥Ä…™ s ú Ä·¥á·¥á ·¥ã Ä…™s ú…¥",
            "·¥ä·¥Ä…™ s ú Ä·¥á·¥á  Ä·¥Ä·¥Ö ú·¥á",
            " Ä·¥Ä·¥Ö ú·¥á  Ä·¥Ä·¥Ö ú·¥á",
            "s·¥Ä·¥ç ô ú·¥ú",
            "·¥ä·¥Ä…™ ·¥ç·¥Ä·¥õ·¥Ä ·¥Ö…™",
            "·¥ä·¥Ä…™ ·¥ç·¥Ä ú·¥Ä·¥ã·¥Ä·¥Ä ü",
            "·¥ä·¥Ä…™  ô·¥Ä·¥ä·¥Ä Ä·¥Ä…¥…¢ ô·¥Ä ü…™",
        ]
        key = choice(to_key)
        high = max_value
        user_h = [i.mention for i in await c.get_users(max_user)]
        txt = f"""
**…¢…™·¥†·¥á·¥Ä·¥°·¥Ä è ·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á** ‚úÖ
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚â° Total participants: {len(total_entries[c_id])}
‚â° ·¥õ·¥è·¥õ·¥Ä ü …¥·¥ú·¥ç ô·¥á Ä ·¥è“ì ·¥†·¥è·¥õ·¥ás: {len(voted_user[c_id])}

‚â° …™·¥õ's a ·¥õ…™·¥á  ô·¥á·¥õ·¥°·¥á·¥á…¥ “ì·¥è ü ü·¥è·¥°…™…¥…¢ ·¥ús·¥á Äs:
{", ".join(user_h)}
‚â° ·¥õ ú·¥á è ·¥á·¥Ä·¥Ñ ú …¢·¥è·¥õ üó≥ : `{high}` ·¥†·¥è·¥õ·¥ás
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
>>>·¥õ ú·¥Ä…¥·¥ãs “ì·¥è Ä ·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä·¥õ…™…¥…¢

·¥õ ú·¥á ·¥ús·¥á Ä ·¥° ú·¥è ·¥°…™ ü ü ·¥Ñ·¥è·¥ç·¥ç·¥á…¥·¥õ ·¥õ ú·¥á ·¥Ñ·¥è·¥Ö·¥á ·¥°…™ ü ü ·¥°…™…¥ üôÇ
·¥Ñ·¥è·¥Ö·¥á: `{key}`
"""
    await c.send_message(c_id, txt)
    clean_values(c_id)
    await m.reply_text("s·¥õ·¥è·¥ò·¥ò·¥á·¥Ö …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è")


@Hiroko.on_message(filters.command("startvote",)
async def start_the_vote(c: Hiroko, m: Message):
    u_id = m.from_user.id
    curr = GA.give_info(u_id=m.from_user.id)
    if not curr:
        await m.reply_text(" è·¥è·¥ú  ú·¥Ä·¥†·¥á …¥·¥è·¥õ s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥Ä…¥ è …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è  è·¥á·¥õ")
        return
    if not curr["is_give"]:
        await m.reply_text(" è·¥è·¥ú  ú·¥Ä·¥†·¥á …¥·¥è·¥õ s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥Ä…¥ è …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è  è·¥á·¥õ")
        return
    c_id = curr["chat_id"]
    user = curr["user_id"]
    if len(is_start_vote):
        if m.chat.id in is_start_vote:
            await m.reply_text("·¥†·¥è·¥õ…™…¥…¢ …™s ·¥Ä ü Ä·¥á·¥Ä·¥Ö è s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö “ì·¥è Ä ·¥õ ú…™s ·¥Ñ ú·¥Ä·¥õ")
            return
    if len(m.text.split(None)) == 2:
        await message_editor(c, m, c_id)
    else:
        await m.reply_text("…¥·¥è ·¥ç·¥áss·¥Ä…¢·¥á  ü…™…¥·¥ã ·¥ò Ä·¥è·¥†…™·¥Ö·¥á·¥Ö ·¥õ·¥è ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á s·¥õ·¥Ä·¥õ·¥ús ·¥õ·¥è ·¥Ñ ü·¥ès·¥á·¥Ö")
    GA.stop_entries(u_id)
    if u_id != user:
        await m.reply_text(" è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥õ ú·¥á ·¥è…¥·¥á ·¥° ú·¥è  ú·¥Ä·¥†·¥á s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥õ ú·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è")
        return
    try:
        if not len(total_entries[c_id]):
            clean_values(c_id)
            await m.reply_text("…¥·¥è ·¥á…¥·¥õ…™ Ä·¥ás “ì·¥è·¥ú…¥·¥Ö")
            return
    except KeyError:
        clean_values(c_id)
        await m.reply_text("…¥·¥è ·¥á…¥·¥õ…™ Ä·¥ás “ì·¥è·¥ú…¥·¥Ö")
        return
    users = await c.get_users(total_entries[c_id])
    c_link = await c.export_chat_invite_link(c_id)
    for user in users:
        u_id = user.id
        full_name = user.first_name
        if user.last_name and user.first_name:
            full_name = user.first_name + " " + user.last_name
        u_name = user.username if user.username else user.mention
        txt = f"""
**·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä…¥·¥õ's …™…¥“ì·¥è:** üîç  „Äã
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚â° ·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä…¥·¥õ …¥·¥Ä·¥ç·¥á : {full_name}
‚â° ·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä…¥·¥õ ID : `{u_id}`
‚â° ·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä…¥·¥õ's {'username' if user.username else "mention"} : {'@'if user.username else ""}{u_name}
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
>>>·¥õ ú·¥Ä…¥·¥ãs “ì·¥è Ä ·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä·¥õ…™…¥…¢
"""
        if not len(user_entry):
            user_entry[c_id] = {u_id: 0}
        else:
            try:
                user_entry[c_id][u_id] = 0
            except KeyError:
                user_entry[c_id] = {u_id: 0}
        vote_kb = IKM([[IKB("‚ù§Ô∏è", f"vote_{c_id}_{u_id}")]])
        um = await c.send_message(c_id, txt, reply_markup=vote_kb)
        if m.chat.username and not c_link:
            c_link = f"https://t.me/{m.chat.username}"
        join_channel_kb = IKM([[IKB("…¢…™·¥†·¥á·¥Ä·¥°·¥Ä è ·¥Ñ ú·¥Ä…¥…¥·¥á ü", url=c_link)]])
        txt_ib = f"·¥†·¥è·¥õ…™…¥…¢  ú·¥Äs  ô·¥á·¥á…¥ s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö „Äã\n\n>>> ú·¥á Ä·¥á …™s  è·¥è·¥ú Ä ·¥†·¥è·¥õ·¥á  ü…™…¥·¥ã :\n ú·¥á Ä·¥á …™s  è·¥è·¥ú Ä ·¥†·¥è·¥õ·¥á ·¥ç·¥áss·¥Ä…¢·¥á  ü…™…¥·¥ã {um.link}.\n\n**·¥õ ú…™…¥…¢s ·¥õ·¥è ·¥ã·¥á·¥á·¥ò …™…¥ ·¥ç…™…¥·¥Ö**\n‚ñ† …™“ì ·¥ús·¥á Ä  ü·¥á·¥õ's ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ ·¥Ä“ì·¥õ·¥á Ä ·¥†·¥è·¥õ…™…¥…¢  è·¥è·¥ú Ä ·¥†·¥è·¥õ·¥á count ·¥°…™ ü ü  ô·¥á ·¥Ö·¥á·¥Ö·¥ú·¥Ñ·¥õ·¥á·¥Ö.\n‚ñ† …™“ì ·¥Ä…¥ ·¥ús·¥á Ä  ü·¥á“ì·¥õ ·¥Ä…¥·¥Ö  Ä·¥á·¥ä·¥è…™…¥s ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ  ú·¥á ·¥°…™ ü ü …¥·¥è·¥õ  ô·¥á ·¥Ä ô ü·¥á ·¥õ·¥è ·¥†·¥è·¥õ·¥á.\n‚ñ† …™“ì ·¥Ä…¥ ·¥ús·¥á Ä …™s …¥·¥è·¥õ ·¥ò·¥Ä Ä·¥õ ·¥è“ì ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ ·¥õ ú·¥á…¥  ú·¥á' ü ü …¥·¥è·¥õ  ô·¥á ·¥Ä ô ü·¥á ·¥õ·¥è ·¥†·¥è·¥õ·¥á"
        await c.send_message(
            u_id, txt_ib, reply_markup=join_channel_kb, disable_web_page_preview=True
        )
        await sleep(3)  # To avoid flood
    GA.start_vote(u_id)
    is_start_vote.append(c_id)
    await m.reply_text("s·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥õ ú·¥á ·¥†·¥è·¥õ…™…¥…¢")
    return




@Hiroko.on_message(filters.command(["enter", "register", "participate"])
async def register_user(c: Hiroko, m: Message):
    curr = GA.is_vote(m.chat.id)
    if not curr:
        await m.reply_text(
            "…¥·¥è …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è ·¥õ·¥è ·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä·¥õ·¥á …™…¥.\n·¥è Ä ·¥ç·¥Ä è  ô·¥á ·¥á…¥·¥õ Ä…™·¥ás ·¥Ä Ä·¥á ·¥Ñ ü·¥ès·¥á·¥Ö …¥·¥è·¥°"
        )
        return
    curr = GA.give_info(m.chat.id)
    if not curr["is_give"]:
        await m.reply_text("…¥·¥è …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è ·¥õ·¥è ·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä·¥õ·¥á …™…¥. ·¥°·¥Ä…™·¥õ “ì·¥è Ä ·¥õ ú·¥á …¥·¥áx·¥õ ·¥è…¥·¥á")
        return
    elif not curr["entries"]:
        await m.reply_text(
            " è·¥è·¥ú ·¥Ä Ä·¥á  ü·¥Ä·¥õ·¥á,\n·¥á…¥·¥õ Ä…™·¥ás ·¥Ä Ä·¥á ·¥Ñ ü·¥ès·¥á·¥Ö ü´§\n·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥ …™…¥ …¥·¥áx·¥õ …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è"
        )
        return
    c_id = curr["chat_id"]
    if len(total_entries):
        try:
            if m.from_user.id in total_entries[c_id]:
                await m.reply_text(" è·¥è·¥ú ·¥Ä Ä·¥á ·¥Ä ü Ä·¥á·¥Ä·¥Ö è  Ä·¥á…¢…™s·¥õ·¥á Ä·¥á·¥Ö.")
                return
        except KeyError:
            pass
    try:
        await c.send_message(m.from_user.id, "·¥õ ú·¥Ä…¥·¥ãs “ì·¥è Ä ·¥ò·¥Ä Ä·¥õ…™·¥Ñ…™·¥ò·¥Ä·¥õ…™…¥…¢ …™…¥ ·¥õ ú·¥á …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è")
    except Exception:
        await m.reply_text(
            "s·¥õ·¥Ä Ä·¥õ ·¥õ ú·¥á  ô·¥è·¥õ “ì…™ Äs·¥õ\n·¥Ä…¥·¥Ö ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥",
            reply_markup=IKM(
                [[IKB("s·¥õ·¥Ä Ä ·¥õ ú·¥á  ô·¥è·¥õ", url=f"https://{Abishnoi.username}.t.me/")]]
            ),
        )
        return
    curr = GA.give_info(m.chat.id)
    c_id = curr["chat_id"]
    if not len(total_entries):
        total_entries[c_id] = [m.from_user.id]
    else:
        try:
            if m.from_user.id not in total_entries[c_id]:
                total_entries[c_id].append(m.from_user.id)
            else:
                pass
        except KeyError:
            total_entries[c_id] = [m.from_user.id]
    await m.reply_text(
        " è·¥è·¥ú ·¥Ä Ä·¥á  Ä·¥á…¢…™s·¥õ·¥á Ä·¥á·¥Ö s·¥ú·¥Ñ·¥Ñ·¥áss“ì·¥ú ü ü è\n**·¥Ö·¥è…¥'·¥õ  ô ü·¥è·¥Ñ·¥ã ·¥õ ú·¥á  ô·¥è·¥õ  ô·¥á·¥Ñ·¥Ä·¥ús·¥á  è·¥è·¥ú ·¥Ä Ä·¥á …¢·¥è…™…¥…¢ ·¥õ·¥è …¢·¥á·¥õ …™…¥“ì·¥è ·¥Ä ô·¥è·¥ú·¥õ …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è ·¥†…™·¥Ä  ô·¥è·¥õ**"
    )
    return


def get_curr_votes(p_id, c_id):
    votess = []
    if votess:
        votess.clear()
    if not len(left_deduct[c_id]):
        votes = 0
        return 0
    for i, j in left_deduct[c_id].items():
        if j == p_id:
            votess.append(i)
    votes = len(votess)
    return votes



@Hiroko.on_callback_query("vote_")
async def vote_increment(c: Hiroko, q: CallbackQuery):
    data = q.data.split("_")
    c_id = int(data[1])
    u_id = int(data[2])
    curr = GA.give_info(c_id)
    if not curr["is_give"]:
        await q.answer("·¥†·¥è·¥õ…™…¥…¢ …™s ·¥Ñ ü·¥ès·¥á·¥Ö")
        return
    if not curr:
        return
    if len(rejoin_try):
        try:
            if q.from_user.id in rejoin_try[c_id]:
                await q.answer(
                    " è·¥è·¥ú ·¥Ñ·¥Ä…¥'·¥õ ·¥†·¥è·¥õ·¥á.  ô·¥á·¥Ñ·¥Ä·¥ús·¥á  è·¥è·¥ú' Ä·¥á  Ä·¥á·¥ä·¥è…™…¥·¥á·¥Ö ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ ·¥Ö·¥ú Ä…™…¥…¢ …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è"
                )
                return
        except KeyError:
            pass
    is_old = curr["is_new"]
    can_old = False
    if is_old:
        can_old = datetime.now() - timedelta(days=2)
    try:
        is_part = await c.get_chat_member(c_id, q.from_user.id)
    except UserNotParticipant:
        await q.answer("·¥ä·¥è…™…¥ ·¥õ ú·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü ·¥õ·¥è ·¥†·¥è·¥õ·¥á", True)
        return
    if is_part.status not in [CMS.MEMBER, CMS.OWNER, CMS.ADMINISTRATOR]:
        await q.answer("·¥ä·¥è…™…¥ ·¥õ ú·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü ·¥õ·¥è ·¥†·¥è·¥õ·¥á", True)
        return
    if can_old and can_old < is_part.joined_date:
        await q.answer("·¥è ü·¥Ö ·¥ç·¥á·¥ç ô·¥á Ä ·¥Ñ·¥Ä…¥'·¥õ ·¥†·¥è·¥õ·¥á", True)
        return
    if not len(voted_user):
        voted_user[c_id] = [q.from_user.id]
    elif len(voted_user):
        try:
            if q.from_user.id in voted_user[c_id]:
                await q.answer(" è·¥è·¥ú  ú·¥Ä·¥†·¥á ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥†·¥è·¥õ·¥á·¥Ö ·¥è…¥·¥Ñ·¥á", True)
                return
            voted_user[c_id].append(q.from_user.id)
        except KeyError:
            voted_user[c_id] = [q.from_user.id]
    try:
        left_deduct[c_id][q.from_user.id] = u_id
    except KeyError:
        left_deduct[c_id] = {q.from_user.id: u_id}
    votes = get_curr_votes(u_id, c_id)
    try:
        user_entry[c_id][u_id] += 1
        new_vote = IKM([[IKB(f"‚ù§Ô∏è {votes}", f"vote_{c_id}_{u_id}")]])
        await q.answer("·¥†·¥è·¥õ·¥á·¥Ö.")
        await q.edit_message_reply_markup(new_vote)
    except KeyError:
        await q.answer("·¥†·¥è·¥õ…™…¥…¢  ú·¥Äs  ô·¥á·¥á…¥ ·¥Ñ ü·¥ès·¥á·¥Ö “ì·¥è Ä ·¥õ ú…™s …¢…™·¥†·¥á·¥Ä·¥°·¥Ä è", True)
        return
    except Exception as e:
        LOGGER.error(e)
        LOGGER.error(format_exc())


@Hiroko.on_message(filters.left_chat_member)
async def rejoin_try_not(c: Hiroko, m: Message):
    user = m.left_chat_member
    if not user:
        return
    Ezio = GA.give_info(m.chat.id)
    if not Ezio:
        return
    Captain = user.id
    if len(voted_user):
        if Captain in voted_user[m.chat.id]:
            GB = int(left_deduct[m.chat.id][Captain])
            user_entry[m.chat.id][GB] -= 1
            await c.send_message(
                GB,
                f"·¥è…¥·¥á ·¥ús·¥á Ä ·¥° ú·¥è  ú·¥Ä·¥†·¥á ·¥†·¥è·¥õ·¥á·¥Ö  è·¥è·¥ú  ü·¥á“ì·¥õ ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ s·¥è  ú…™s ·¥†·¥è·¥õ·¥á …™s  Ä·¥á·¥Ö·¥ú·¥Ñ·¥á·¥Ö “ì Ä·¥è·¥ç  è·¥è·¥ú Ä ·¥õ·¥è·¥õ·¥Ä ü ·¥†·¥è·¥õ·¥ás.\n…¥·¥è·¥õ·¥á ·¥õ ú·¥Ä·¥õ  ú·¥á ·¥°…™ ü ü …¥·¥è·¥õ ·¥Ä ô ü·¥á ·¥õ·¥è ·¥†·¥è·¥õ·¥á …™“ì  ú·¥á  Ä·¥á·¥ä·¥è…™…¥s ·¥õ ú·¥á ·¥Ñ ú·¥Ä·¥õ\n ü·¥á“ì·¥õ ·¥ús·¥á Ä : {Captain}",
            )
            try:
                rejoin_try[m.chat.id].append(Captain)
            except KeyError:
                rejoin_try[m.chat.id] = [Captain]
    else:
        try:
            rejoin_try[m.chat.id].append(Captain)
        except KeyError:
            rejoin_try[m.chat.id] = [Captain]
        return



